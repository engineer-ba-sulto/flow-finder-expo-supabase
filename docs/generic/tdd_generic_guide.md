# TDD 実装ガイド — 汎用的な開発手法

## 1. 概要

このドキュメントは **TDD（Test-Driven Development）** の実装手法を体系化した汎用的なガイドです。プロダクトや技術スタックに依存せず、どのプロジェクトにも適用できる原則と実践方法を記載します。

## 2. TDD の基本原則

### 2.1 Red-Green-Refactor サイクル

| フェーズ           | 目的                     | 実施内容                         | 完了条件                         |
| ------------------ | ------------------------ | -------------------------------- | -------------------------------- |
| **Red Phase**      | 失敗するテスト作成       | 実装前にテストを書く             | テストが失敗する                 |
| **Green Phase**    | 最小限の実装でテスト通過 | テストが通る最小限のコードを書く | テストが通る                     |
| **Refactor Phase** | コード品質向上           | 機能を壊さずにコードを改善する   | テストが通り、コードが改善される |

### 2.2 TDD の価値

- **設計の改善**: テストファーストで API 設計を意識
- **リファクタリング安全性**: 回帰テストによる安心感
- **ドキュメント化**: テストコードが仕様書として機能
- **バグ早期発見**: 開発段階での品質保証

## 3. 技術スタック選択の指針

### 3.1 テスティングフレームワーク選択

| 技術スタック              | 推奨テスティングツール | 特徴                     |
| ------------------------- | ---------------------- | ------------------------ |
| **JavaScript/TypeScript** | Jest + Testing Library | 豊富なエコシステム       |
| **React**                 | React Testing Library  | コンポーネント単位テスト |
| **Vue.js**                | Vue Test Utils         | Vue 特化のテスト         |
| **Node.js**               | Jest + Supertest       | API テスト               |
| **Python**                | pytest                 | 簡潔なテスト記述         |
| **Java**                  | JUnit + Mockito        | 企業標準                 |

### 3.2 TDD 駆動開発ツールチェーン

| 役割                       | 目的                 | 選択基準                 |
| -------------------------- | -------------------- | ------------------------ |
| **テストランナー**         | テスト実行・結果表示 | 高速実行、豊富なレポート |
| **アサーションライブラリ** | テスト条件の検証     | 読みやすい API           |
| **モックライブラリ**       | 依存関係の隔離       | 簡単なスタブ作成         |
| **カバレッジツール**       | テスト網羅率測定     | 詳細なレポート           |
| **CI/CD**                  | 自動テスト実行       | 高速、信頼性             |

## 4. 段階的実装戦略

### 4.1 Phase 基盤実装戦略

#### Phase 1: 基盤構築（週 1-2）

- **目標**: 基本的なアーキテクチャ確立
- **実装対象**:
  - 基本コンポーネント（UI 要素）
  - データ層（API クライアント）
  - 認証・認可
  - 基本的なページ構成

#### Phase 2: 主要機能実装（週 3-5）

- **目標**: コア機能の実装
- **実装対象**:
  - ビジネスロジック
  - ユーザーインタラクション
  - 状態管理
  - 統合機能

#### Phase 3: リリース準備（週 6）

- **目標**: 本番環境対応
- **実装対象**:
  - 外部サービス連携
  - 監視・ログ機能
  - パフォーマンス最適化
  - セキュリティ対策

### 4.2 タスク分割の原則

| 分割サイズ | 実装時間 | テスト作成時間 | 適用例             |
| ---------- | -------- | -------------- | ------------------ |
| **小**     | 0.5-1 日 | 0.5-1 日       | 単一コンポーネント |
| **中**     | 1-2 日   | 1-2 日         | 機能単位           |
| **大**     | 2-3 日   | 2-3 日         | ページ単位         |

## 5. TDD 実践ガイドライン

### 5.1 Red Phase（失敗するテストを書く）

#### 基本原則

- **具体的なテスト**: 曖昧な条件は避ける
- **単一責任**: 1 つのテストで 1 つの機能のみ検証
- **読みやすさ**: テストは仕様書として機能

#### テスト作成パターン

```typescript
// パターン1: 単純な入出力テスト
describe("関数名", () => {
  it("正常なケース: 期待する結果を返す", () => {
    // Arrange (準備)
    const input = "入力値";
    const expected = "期待値";

    // Act (実行)
    const result = targetFunction(input);

    // Assert (検証)
    expect(result).toBe(expected);
  });
});

// パターン2: 状態変化テスト
describe("コンポーネント名", () => {
  it("ユーザー操作時: 状態が適切に変化する", () => {
    // Arrange
    const component = render(<Component />);

    // Act
    fireEvent.click(component.getByText("ボタン"));

    // Assert
    expect(component.getByText("変化後の状態")).toBeInTheDocument();
  });
});
```

### 5.2 Green Phase（最小限の実装）

#### 基本原則

- **最小実装**: テストが通る最小限のコード
- **ハードコーディング許可**: 最初はベタ書きでも良い
- **重複を恐れない**: 後でリファクタリングする

#### 実装パターン

```typescript
// Step 1: 最小実装（ハードコーディング）
function calculate(input: number): number {
  return 42; // テストが通る値を直接返す
}

// Step 2: 少し汎用化
function calculate(input: number): number {
  if (input === 1) return 42;
  if (input === 2) return 84;
  return 0;
}

// Step 3: 一般化（リファクタリング段階）
function calculate(input: number): number {
  return input * 42;
}
```

### 5.3 Refactor Phase（コード改善）

#### 改善対象

- **重複コードの削除**: DRY 原則の適用
- **命名の改善**: 意図が明確な名前
- **構造の改善**: 責任の分離
- **パフォーマンス**: 必要に応じて最適化

#### リファクタリング原則

1. **小さな変更**: 一度に 1 つの改善
2. **テスト実行**: 変更後は必ずテスト実行
3. **継続的改善**: 完璧を目指さず、少しずつ改善

## 6. テスト戦略

### 6.1 テストピラミッド

```
       /\
      /  \
     / E2E \ (少数)
    /------\
   /        \
  /Integration\ (中程度)
 /____________\
/              \
    Unit Test     (多数)
```

| レベル          | 比率 | 実行速度 | 信頼性 | 保守性 |
| --------------- | ---- | -------- | ------ | ------ |
| **Unit**        | 70%  | 高速     | 高     | 高     |
| **Integration** | 20%  | 中速     | 中     | 中     |
| **E2E**         | 10%  | 低速     | 低     | 低     |

### 6.2 テスト分類

#### Unit Test（単体テスト）

- **対象**: 個別の関数・クラス・コンポーネント
- **分離**: 外部依存をモックで隔離
- **カバレッジ目標**: 80%以上

#### Integration Test（統合テスト）

- **対象**: 複数モジュールの連携
- **分離**: 外部サービスはモック
- **カバレッジ目標**: 60%以上

#### E2E Test（エンドツーエンドテスト）

- **対象**: ユーザーシナリオ全体
- **分離**: 本番環境に近い状態
- **カバレッジ目標**: 主要フロー全て

### 6.3 テストケース設計

#### 境界値テスト

- **最小値**: 範囲の最小値
- **最大値**: 範囲の最大値
- **境界値**: 範囲の境界 ±1

#### 等価分割テスト

- **正常系**: 期待される入力
- **異常系**: エラーが発生する入力
- **境界系**: 境界値での動作

## 7. 品質保証

### 7.1 継続的インテグレーション

#### 必須チェック項目

- **テスト実行**: 全テストが通る
- **カバレッジ**: 目標値以上
- **型チェック**: 型エラーなし
- **静的解析**: Lint エラーなし
- **セキュリティ**: 脆弱性なし

#### 品質ゲート

```yaml
# 品質ゲート設定例
quality_gates:
  unit_test_coverage: 80%
  integration_test_coverage: 60%
  e2e_test_pass_rate: 100%
  build_success_rate: 100%
  security_vulnerabilities: 0
```

### 7.2 品質メトリクス

#### 開発効率指標

- **テスト実行時間**: 目標時間以内
- **ビルド時間**: 目標時間以内
- **バグ検出率**: テスト段階での検出率

#### 品質指標

- **テストカバレッジ**: 種類別達成率
- **バグ密度**: 機能あたりのバグ数
- **技術的負債**: 保守性指標

## 8. チーム運用

### 8.1 ブランチ戦略

#### フィーチャーブランチ戦略

```
main
├── feat/tdd-feature-a-red
├── feat/tdd-feature-a-green
├── feat/tdd-feature-a-refactor
└── feat/tdd-feature-b-red
```

#### コミット規則

```
<type>(<scope>): <description>

types:
- test: テスト追加・修正
- feat: 機能実装
- refactor: リファクタリング
- fix: バグ修正
- docs: ドキュメント
```

### 8.2 レビュー観点

#### TDD 特有の観点

- **テストファースト**: テストが先に作成されているか
- **適切なテスト**: 仕様を適切に検証しているか
- **最小実装**: 過度な実装になっていないか
- **リファクタリング**: 適切に改善されているか

#### 一般的な観点

- **可読性**: コードが読みやすいか
- **保守性**: 変更しやすい構造か
- **パフォーマンス**: 性能問題はないか
- **セキュリティ**: 脆弱性はないか

## 9. リスク管理

### 9.1 TDD 特有のリスク

| リスク                     | 影響度 | 対策                     |
| -------------------------- | ------ | ------------------------ |
| **テスト作成時間の増加**   | 中     | 小さな単位から始める     |
| **過度なテスト**           | 中     | 価値のあるテストに集中   |
| **リファクタリング恐怖症** | 高     | 定期的なリファクタリング |
| **テストの品質低下**       | 高     | テストコードレビュー     |

### 9.2 技術的リスク

| リスク                 | 対策                         |
| ---------------------- | ---------------------------- |
| **テスト環境の不安定** | 安定した CI/CD 環境構築      |
| **外部依存の影響**     | 適切なモック戦略             |
| **パフォーマンス劣化** | 定期的なパフォーマンステスト |
| **技術的負債の蓄積**   | 継続的なリファクタリング     |

## 10. 成功指標

### 10.1 品質指標

#### 定量的指標

- **テストカバレッジ**: Unit 80%以上、Integration 60%以上
- **バグ検出率**: 開発段階で 80%以上
- **テスト実行時間**: 目標時間以内
- **ビルド成功率**: 95%以上

#### 定性的指標

- **コードの可読性**: レビューでの評価
- **保守性**: 変更の容易さ
- **チーム満足度**: 開発体験の改善

### 10.2 開発効率指標

#### 速度指標

- **開発速度**: 機能あたりの開発時間
- **バグ修正時間**: 平均修正時間
- **デプロイ頻度**: リリース頻度

#### 安定性指標

- **変更失敗率**: デプロイ失敗率
- **復旧時間**: 障害からの復旧時間
- **リードタイム**: 開発からリリースまでの時間

## 11. 適用ガイドライン

### 11.1 プロジェクト開始時

1. **技術スタック決定**

   - 要件に応じたテスティングツール選択
   - CI/CD パイプライン設計
   - 品質ゲート設定

2. **チーム準備**
   - TDD 研修実施
   - ブランチ戦略合意
   - レビュー観点共有

### 11.2 実装フェーズ

1. **Phase 1: 基盤構築**

   - 最小限の機能で TDD サイクル確立
   - 基本的なテスト環境構築
   - チーム間での手順共有

2. **Phase 2: 機能拡張**

   - 複雑な機能の TDD 適用
   - 統合テストの充実
   - 継続的な改善

3. **Phase 3: 本番対応**
   - E2E テストの実装
   - 性能・セキュリティテスト
   - 運用監視の準備

### 11.3 継続的改善

- **定期的な振り返り**: TDD 効果の測定
- **プロセス改善**: ボトルネックの解消
- **ツール改善**: 効率化の推進
- **知識共有**: ベストプラクティス蓄積

---

このガイドは TDD の基本原則と実践方法を体系化したものです。各プロジェクトの特性に応じて、具体的な実装計画を作成する際の参考としてご活用ください。
